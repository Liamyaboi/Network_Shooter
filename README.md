# Network_Shooter

I began the project by downloading the necessary Unity packages to enable Netcode functionality. To streamline my workflow, I set up an editor cloner that would mirror changes in a second editor. This meant I didn’t have to rebuild the entire project after each minor change, which saved a lot of time. 

With that in place, I created a Network Manager and added the required "Network Manager" and "Unity Transport" scripts from the Netcode package. The next task was to create a player prefab, which I then registered in the Network Manager under "Player Prefab" and "DefaultNetwork Prefabs (Network Prefab List)" to ensure the network could recognize the player. 

Once the player prefab was set up, I attached the Network Object script, also from the Netcode package, and added a Client Transform Script (ClientAuthorityManager) that I found online. This script was crucial for synchronizing player positions across both the host and client. I applied this Client Authority Manager to all network objects that needed to move. 

The player controller, I implemented an OnNetworkSpawn function, which is similar to the Start function but triggers when the network is initialized. Inside this method, I set up the player’s camera, and in the Update method, I ensured each player had their own camera controlling the mouse coordinates. I added mouse input logic that made the player rotate toward the mouse, simplifying the setup for the bullet direction later. I also decided that the player would only rotate toward the mouse when holding down the W key, preventing constant movement and giving the player more control. 

Once the movement was sorted, I focused on the bullet mechanic. Since the player was already rotating in the mouse’s direction, I added an invisible object in front of the player, called ArrowDirection, which served as the spawn point for the bullets. I turned the bullets into network objects and applied the “Network Transport” script to ensure they were correctly synchronized across the network. To handle the bullet spawning over the network, I used a ServerRpc function, which allowed the host to manage bullet instantiation. This function was called within the player controller’s OnNetworkSpawn method and later triggered in Update when the player clicked the left mouse button. 

I ran into an issue where multiple bullets would spawn simultaneously. To fix this, I ensured that only the host could update or destroy objects. Without this safeguard, clients would attempt to destroy objects they didn’t have permission to, which resulted in errors. This became a problem when I set up the bullets to self-destruct after traveling a certain distance. The solution was to make sure only the host could manage the destruction of bullets, which resolved the issue. 

Next, I decided to give the player something to shoot at, so I created asteroids that would spawn off-screen and move toward the center. I set up an InvokeRepeating function in the Start method to spawn asteroids every two seconds. This function called SpawnAsteroidsServerRpc, which was responsible for spawning the asteroids on the server. To calculate their spawn positions, I created a helper function called GetRandomSpawnPosition. This calculated random spawn points just outside the visible screen area, ensuring that the asteroids would appear on the edges of the screen. Like the bullets, the asteroids were also set to self-destruct after traveling a certain distance. 

I ran into some trouble with spawning the asteroids over the network. The problem was that the asteroid spawner itself needed to be handled by the server. Instead of placing the spawner logic inside the player controller, I realized it would be more efficient to create a GameNetworkManager to manage network spawns. However, due to time constraints, I opted for a quicker solution. In the OnNetworkSpawn method, I made sure the asteroid spawner was initialized properly on the network, which resolved the issue. 

Once the spawner was working, I added a simple collision detection system where bullets destroy asteroids, and asteroids break upon hitting the player. This was straightforward to implement. 

For player communication, I added a feature for a emote, allowing players to express themselves through emojis. This was done using ClientRpc, which made the process fairly easy to set up. 

Finally, I addressed the packet loss and delay issues that appeared when firing bullets. The problem was related to the Interpolate function in the Network Transform, which smooths the movement but also introduces some lag. This issue only occurred when there wasn’t a host, and players connected directly to a server. As a fallback, I considered adding a slight delay before destroying objects to help with synchronization. 
